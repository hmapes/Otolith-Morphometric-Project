---
title: "Vermilion-Sunset-Otolith-Morphology-Comparison"
author: "Rachel Brooks"
format: html
editor: visual
---


## Load ShapeR

This chunk load shapeR and retrieve data, as well as sets project path folder.


```{r, warning=FALSE}

# load shape R and retrieve data
library(here)
library(shapeR)

#Set project path to the folder 'ShapeAnalysis'
shape <- shapeR(
  project.path = here("ShapeR", "ShapeAnalysis"), 
  info.file = "VRML-SUNS-subset.csv"
)

```


## Creating a ShapeR object outline from image files

**detect.outline():** Obtain the outline of each otolith. The outlines are detected by first transforming the images into gray-scale. The images are then binarized using a threshold pixel value (intensity threshold) which can be defined by the user. The outlines are then collected automatically from all images in the folder 'Fixed'. Modification of the outlines are stored in different slots within the shape data object.

-   **threshold** argument is used to distinguish the white otolith from black background (essentially increases contrast)

-   **write.outline.w.org** argument determines whether the detected outline should be written on top of the original image (TRUE) or not (FALSE) in the folder 'Original_with_outline' which shapeR makes automatically and places into the folder 'ShapeAnalysis'. *It is recommended to run the images with the write.outline.w.org = TRUE the first time the images are run for quality checking, to see if the outline fits the original image from the microscope.*

    -   If an error occurs, or the outline is of low quality, the outline can be removed from the shapeR instance:

        > *shape = remove.outline(shape,"IC","403_54")*

    -   To view an individual otolith with outline:

        > *show.original.with.outline(shape,"IC","403_54")*

-   **smoothout** argument calculates a weighted moving average over three succesive coordinate points to smooth multiple outlines. The number of iterations (ex: n = 100) provided by the user is the maximum number of iterations of smoothing. This argument is used to reduce high frequency pixel noise around the outlines which can corrupt Fourier or Wavelength analysis.

-   **generateShapeCoefficients** argument extracts the shape coefficient from the captured outlines

-   **enrich.master.list** argument connects data file containing information on origin and size of the fish to the outlines


```{r}

# Trace orange outline around otolith - saves in Original_with_outline
shape = detect.outline(shape, threshold = 0.20, write.outline.w.org = TRUE)

# Smooth outlines 
shape = smoothout(shape, n = 100)

# Extract shape coefficient
shape = generateShapeCoefficients(shape)

# Connect data file 'FISH.csv' to the outlines
shape = enrich.master.list(shape)

# Save shape object
save(shape, file = "VRML-SUNS-subset.RData")

```


## Mean otolith shape

-   plotWaveletShape argument plots the mean otolith shape using the Wavelet coefficients

-   plotFourierShape argument plots the mean otolith shape using the Wavelet coefficients

    -   Can adjust parameter to an alternate variable depending on what you're looking to compare (i.e., "sex", "species", etc.) - here we're comparing species using the "PacFIN_Species_Code"


```{r}
# Plot mean otolith shape using Wavelet coefficient 
png("wavelet_shape_plot.png", width = 2500, height = 1500, res = 300)
plotWaveletShape(shape, "PacFIN_Species_Code", show.angle = TRUE, lwd = 2,lty = 1)
dev.off()

# Plot mean otolith shape using Fourier coefficient
png("Fourier_shape_plot.png", width = 2500, height = 1500, res = 300)
plotFourierShape(shape, "PacFIN_Species_Code", show.angle = TRUE, lwd = 2,lty = 1)
dev.off()

```


## Morphometric measurements

-   First, you will nedd to extract the `master.list` data frame from the `shape` object and assign it to a new variable. I called it `fish_data`. Now you can work with `fish_data` as a regular data frame in your analyses or plotting.

-   **getMeasurements** argument allows you to collect all otolith measurements (otolith length, width, perimeter, and area) from unstandardized otoliths

    -   Feret length and width are concepts used in image analysis to describe the maximum distance between two parallel lines tangent to an object - measuring the longest distance across an object, regardless of orientation.

    -   For each species, the mean for the variables in the summary statistics (area, length, perimeter, width) can be calculated:

        > *tapply(getMeasurements(shape)\$otolith.area, getMasterlist(shape)\$PacFIN_Species_Code, mean)*

-   **getStdMeasurements** argument allows you to collect all otolith measurements (otolith length, width, perimeter, and area) from standardized otoliths


```{r}

fish_data <- shape@master.list

# Get length, width, area, perimeter of otolith
measurements <- getMeasurements(shape)

# Calculate mean of the otolith morphometric variable: 
# Otolith area
tapply(getMeasurements(shape)$otolith.area, 
       getMasterlist(shape)$PacFIN_Species_Code, mean)
# Otolith perimeter
tapply(getMeasurements(shape)$otolith.perimeter, 
       getMasterlist(shape)$PacFIN_Species_Code, mean)
# Otolith length
tapply(getMeasurements(shape)$otolith.length, 
       getMasterlist(shape)$PacFIN_Species_Code, mean)
# Otolith width
tapply(getMeasurements(shape)$otolith.width, 
       getMasterlist(shape)$PacFIN_Species_Code, mean)

```


## Adjusting coefficients for fish length and wavelet/fourier reconstruct

-   **stdCoefs** argument evaluates each Wavelet and Fourier coefficient and adjusts the otolith shape with respect to allometric relationships with the fish lengths.

    -   Those coefficients which show interaction (P\<0.05), between population and length, are omitted automatically.

    -   In order to account for increased alpha error due to multiple testing of the different coefficients it is possible to conduct the Bonferroni adjustment

-   **estimate.outline.reconstruction** argument estimates the quality of the Wavelet and Fourier reconstruction by comparing how it deviates from otolith outline

    -   The quality increases with the increase of Wavelet/Fourier coefficients used

-   **plotWavelet** argument can be used to inspect how the variation in the Wavelet coefficients is dependent on the position along the outline. The proportion of variation among groups, the interclass correlation (ICC), gives further information about the partition of the variation along the outline


```{r}

shape = stdCoefs(shape, classes = "PacFIN_Species_Code", "Wgt_g", 
                 bonferroni = TRUE)

est.list = estimate.outline.reconstruction(shape)

outline.reconstruction.plot(est.list, max.num.harmonics = 15)

plotWavelet(shape, level = 5, class.name = "PacFIN_Species_Code", 
            useStdcoef = TRUE)

```


## Morphometric comparison plots

-   Box and whisker plots comparing the four otolith morphometrics between vermilion and sunset

-   Statistical analysis:

    -   Before comparing each group check data for distribution and variance

    -   Compare groups using either a wilcoxon rank-sum test (non-normal) or student's t-test (normal and equal variance)

| Scenario                       | Recommended Test       |
|--------------------------------|------------------------|
| Two groups, non-normal data    | Wilcoxon rank-sum test |
| Two groups, normal + equal var | Student's t-test       |


```{r}

library(ggplot2)
library(tidyr)
library(dplyr)
library(patchwork)


# Define morphometric columns
morphometrics <- c("otolith.length", "otolith.width", "otolith.area", "otolith.perimeter")

# Reshape data
long_data <- fish_data %>%
  select(Species, all_of(morphometrics)) %>%
  pivot_longer(cols = all_of(morphometrics),
               names_to = "morphometric",
               values_to = "value")

# Create a list of plots for each morphometric
plots <- long_data %>%
  group_split(morphometric) %>%
  lapply(function(df) {
    morph_name <- unique(df$morphometric)
    
    ggplot(df, aes(x = Species, y = value)) +
      geom_boxplot(outlier.shape = NA, fill = "lightblue", color = "darkblue") +
      geom_jitter(width = 0.2, alpha = 0.3, size = 0.7) +
      theme_minimal() +
      labs(
        title = NULL,
        x = "",
        y = morph_name  # dynamic y-axis label
      ) +
      theme(
        axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(size = 14, face = "bold")
      )
  })

# Combine plots with patchwork
wrap_plots(plots, ncol = 2)

# Save as high-res PNG
ggsave("otolith_morphometrics-comp-subset.png", plot = last_plot(), width = 8, height = 6, dpi = 300)

# Run t-test (normal distributed data) or wilcoxon rank-sum test to compare otolith shape/size among populations
library(rstatix)

#Normally distributed data
t_test_results <- list()

for (metric in morphometrics) {
  formula <- as.formula(paste(metric, "~ Species"))
  result <- fish_data %>%
    t_test(formula)

  cat("\n\n---", metric, "---\n")
  print(result)

  t_test_results[[metric]] <- result
}


# NOT normally distributed 
wilcox_results <- list()

for (metric in morphometrics) {
  formula <- as.formula(paste(metric, "~ Species"))
  result <- fish_data %>% 
    wilcox_test(formula)
  
  # Print summary
  cat("\n\n---", metric, "---\n")
  print(result)
  
  # Store result
  wilcox_results[[metric]] <- result
}

```


## Otolith shape analysis

-   Load **vegan package** (used for multivariate ecological analyses

-   Extract both the standardized wavelet coefficients (wavelet_data) and corresponding metadata (meta_data) - check that the number of rows (individuals) matches in both datasets.

-   Perform Canonical Analysis of Principal Coordinates (CAP) to test how well otolith shape (wavelet data) can discriminate between species (can use 'PacFIN_Species_Code' or 'Species' column). I used euclidian distances between samples, since data are continuous measurements (wavelet coefficient shape descriptors) and euclidian preserves linear geometry.

    -   `summary()`: Shows the proportion of variance explained by each CAP axis.

    -   `anova()`: Tests overall significance of the CAP model.

    -   `anova(..., by = "terms")`: Tests the significance of each term (e.g., species) individually.

-   Make the CAP plot

    -   Plot the CAP results (no points initially, just axes).

    -   Adds colored points by species

    -   Adds a legend mapping colors to species.

    -   Extract CAP scores for each fish and store them with species labels for further plotting/analyses.

    -   Plot ellipses for each group - there is code to plot this for 1 SD and 95% CI.

    -   Use `ordispider()` to draw lines from group centroids to individual points.


```{r}

library(vegan)

# Extract standardized wavelet coefficients
wavelet_data <- shape@wavelet.coef.std

# Extract corresponding metadata (fish info)
meta_data <- shape@master.list

# Make sure dimensions match
dim(wavelet_data)  # n rows = individuals
dim(meta_data)

# CAP analysis
cap_model <- capscale(wavelet_data ~ PacFIN_Species_Code, data = meta_data, distance = "euclidean")

# View summary
summary(cap_model)

# Test significance of the model
anova(cap_model)

# Optional: Test individual terms (like 'Species')
anova(cap_model, by = "terms")


#VEGAN PLOT

plot(cap_model, display = "sites", type = "n", main = "CAP of Otolith Wavelet Shape")
points(cap_model, display = "sites", col = as.factor(meta_data$PacFIN_Species_Code), pch = 19)
legend("topright", legend = unique(meta_data$PacFIN_Species_Code), 
       col = 1:length(unique(meta_data$PacFIN_Species_Code)), pch = 19)

# Extract CAP site scores
cap_scores <- scores(cap_model, display = "sites")  # site (individual) scores
scores_df <- as.data.frame(cap_scores)
scores_df$species <- meta_data$PacFIN_Species_Code


#SD confidence interval

# Create a blank base plot
plot(cap_model, display = "sites", type = "n", 
     main = "CAP of Otolith Wavelet Shape",
     xlab = "CAP1", ylab = "MDS1")

# Add points colored by species
points(cap_model, display = "sites", 
       col = as.factor(meta_data$PacFIN_Species_Code), 
       pch = 19)

# Add 1 standard deviation ellipses around each species group
ordiellipse(cap_model, groups = meta_data$PacFIN_Species_Code, 
            display = "sites", kind = "sd", 
            col = 1:2, lwd = 2, draw = "lines")

# Add centroid “spiders” from group centroid to each point
ordispider(cap_model, groups = meta_data$PacFIN_Species_Code, 
           display = "sites", col = 1:2, lty = 2)

# Add legend
legend("topright", legend = levels(as.factor(meta_data$PacFIN_Species_Code)),
       col = 1:2, pch = 19, lwd = 2, bty = "n")


#### 95% confidence interval

# Base CAP plot
plot(cap_model, display = "sites", type = "n", 
     main = "CAP of Otolith Shape (95% CI Ellipses)",
     xlab = "CAP1", ylab = "MDS1")

# Points
points(cap_model, display = "sites", 
       col = as.factor(meta_data$PacFIN_Species_Code), 
       pch = 19)

# 95% CI ellipses
ordiellipse(cap_model, 
            groups = meta_data$PacFIN_Species_Code, 
            display = "sites", 
            kind = "se", 
            conf = 0.95, 
            col = 1:2, lwd = 2, lty = 2)

# Optional: centroids via spiders
ordispider(cap_model, 
           groups = meta_data$PacFIN_Species_Code, 
           display = "sites", 
           col = 1:2, lty = 3)

# Legend
legend("topright", 
       legend = levels(as.factor(meta_data$PacFIN_Species_Code)),
       col = 1:2, pch = 19, bty = "n")
```

```{r}

write.csv(fish_data, "fish_data_measurements.csv", row.names = FALSE)

```


## Comparing different morphometric sources

-   This is where I compare caliper vs. ImageJ vs. ShapeR measurements. Plotting linear relationships between the different sources. Include a 1:1 line in the plot and compare linear fit of the different morphometric sources to the 1:1 line.


```{r}

#Caliper Comparison
ggplot(fish_data, aes(x = otolith.length, y = Caliper_length_mm)) +
  geom_point(alpha = 0.6, color = "blue") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red", size = 1) +
  geom_smooth(method = "lm", se = TRUE, color = "black") +
  scale_x_continuous(name = "ShapeR Measurement", limits = c(15, NA)) +  # Start x-axis at 1
  scale_y_continuous(name = "Caliper Measurement", limits = c(15, NA)) +  # Start y-axis at 1
  labs(title = "Otolith Length (mm)") +
  theme_minimal()

ggplot(fish_data, aes(x = otolith.width, y = Caliper_width_mm)) +
  geom_point(alpha = 0.6, color = "blue") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red", size = 1) +
  geom_smooth(method = "lm", se = TRUE, color = "black") +
  scale_x_continuous(name = "ShapeR Measurement", limits = c(8, NA)) +  # Start x-axis at 1
  scale_y_continuous(name = "Caliper Measurement", limits = c(8, NA)) +  # Start y-axis at 1
  labs(title = "Otolith Width (mm)") +
  theme_minimal()



#ImageJ Comparison
ggplot(fish_data, aes(x = otolith.length, y = ImageJ_length_pix_mm)) +
  geom_point(alpha = 0.6, color = "blue") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red", size = 1) +
  geom_smooth(method = "lm", se = TRUE, color = "black") +
  scale_x_continuous(name = "ShapeR Measurement", limits = c(15, NA)) +  # Start x-axis at 1
  scale_y_continuous(name = "ImageJ Measurement", limits = c(15, NA)) +  # Start y-axis at 1
  labs(title = "Otolith Length (mm)") +
  theme_minimal()

ggplot(fish_data, aes(x = otolith.width, y = ImageJ_width_pix_mm)) +
  geom_point(alpha = 0.6, color = "blue") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red", size = 1) +
  geom_smooth(method = "lm", se = TRUE, color = "black") +
  scale_x_continuous(name = "ShapeR Measurement", limits = c(8, NA)) +  # Start x-axis at 1
  scale_y_continuous(name = "ImageJ Measurement", limits = c(8, NA)) +  # Start y-axis at 1
  labs(title = "Otolith Width (mm)") +
  theme_minimal()

```


# Classifications of Individuals

-   This chunk of code is running a cross-validation analysis using Linear Discriminant Analysis (LDA) to classify fish to their species based on wavelet shape descriptors extracted from their otoliths.

-   The cross validation classification estimate produces a missclassification error

```         
-   **EX:** If you receive a misclassification error of 0.2051, this means 20.5% of fish were misclassified, or 79.5% were correctly classified

-   May receive a "*Warning: variables are collinear*" warning - this comes from LDA beign applied to many correlated wavelet coefficients (common in shape analysis). It doesn't stop the analysis but warns that some predictors may be redundant.
```


```{r}

library(MASS)     # For lda()
library(ipred)    # For errorest()

# Define prediction function
mypredict.lda <- function(object, newdata) {
  predict(object, newdata = newdata)$class
}

# Get data
stdw <- getStdWavelet(shape)
species <- factor(getMasterlist(shape)$PacFIN_Species_Code)
dd <- data.frame(stdw = stdw, PacFIN_Species_Code = species)

# Run cross-validation classification accuracy estimate
errorest(PacFIN_Species_Code ~ ., data = dd, model = lda, estimator = "cv", 
         predict = mypredict.lda, est.para = control.errorest(nboot = 1000))
```

